\section{Question 2}

\begin{verbatim}
Examine the use of Clojure's core.spec contract system in several
real world code bases. Look at what features are used, and how precise
specifications are. Analyze how specifications address the lack of
higher-order contracts by looking at the frequency of higher-order function
contracts vs higher-order functions that omit specifications of higher-order
arguments or results.
\end{verbatim}

\subsection{clojure.spec}

Recently, Clojure added a runtime verification system to its core library called
\texttt{clojure.spec}.
It resembles common approaches to runtime verification, such as Racket's contract
system, but is different in several important ways.

Firstly, \texttt{clojure.spec} is designed to treat most values as ``data at rest''. That is,
at verification sites, values are eagerly traversed without waiting to see
if or how the program actually uses them.
When we consider that \texttt{clojure.spec} treats infinite streams
and functions as data at rest, we begin to see the tradeoffs that have been
made.

Secondly, specifications (called ``specs'') are not enforced by default. Users must
opt-in to enforcing specs via an explicit instrumentation phase.
This is also different than most contract systems, many of which are enforced
by default. There is no standard way to integrate spec enforcement into a
test suite, so it is difficult to tell whether specific specs are primarily 
unchecked documentation, or actually used for runtime verification.

Since \texttt{clojure.spec} has a unique feature set amongst runtime verification
libraries, it is interesting to consider how programmers use \texttt{clojure.spec}
in practice. For example, do programmers find the semantics of treating functions
as data at rest useful?

Unfortunately, specs are opt-in with non-standard hooks, so it is difficult to
correlate someone writing a spec with that person \emph{using} the spec, which
would imply the person finding the spec's semantics useful.
Nevertheless, in the following sections we attempt to draw conclusions about
spec's common usage based mostly on the frequency of spec annotations.

\subsection{Function specifications in clojure.spec}

From here, we map the namespace prefix \texttt{s} to \texttt{clojure.spec.alpha},
and \texttt{stest} to \texttt{clojure.spec.test.alpha}.

\begin{verbatim}
(require '[clojure.spec.alpha :as s])
\end{verbatim}

There are two kinds of function checking semantics in \texttt{clojure.spec}.
We use \texttt{intmap}, a higher-order function that maps a function over 
a collection of ints, to demonstrate both semantics.

\begin{verbatim}
(defn intmap
  "Maps a collection of ints over a function."
  [f c]
  (map f c))
\end{verbatim}

If the programmer wants to write a higher-order function spec to
verify \texttt{intmap}, they might write the following spec.

\begin{verbatim}
(s/fdef intmap
  :args (s/cat :f (s/fspec :args (cat :x int?) :ret int?)
               :c (s/coll-of int?))
  :ret (s/coll-of int?))
\end{verbatim}

The \texttt{s/fdef} form signals we are annotating a top-level
function, in this case \texttt{intmap}. Argument specs are
provided with the \texttt{:args} keyword option
in the form of the ``tagged'' heterogeneous collection spec
\texttt{s/cat}---here 2 arguments are allowed, tagged as
\texttt{:f} for the function and \texttt{:c} as the collection.

The \texttt{s/fspec} spec is another kind of function spec,
specifically for non-top-level functions (like function arguments
to top-level functions). It has a similar syntax to \texttt{s/fdef},
but a function name is not provided.

In a nutshell, \texttt{s/fdef} provides traditional proxy-based
verification semantics while \texttt{s/fspec} uses eager \emph{generative testing}
to exercise a function before letting it pass the spec boundary, bare (without a proxy).

We will now demonstrate how the following call gets checked.

\begin{verbatim}
(intmap inc [1 2 3])
;=> (2 3 4)
\end{verbatim}

First, the programmer instruments \texttt{intmap} with:

\begin{verbatim}
(stest/instrument `intmap)
\end{verbatim}

This mutates the top-level binding associated with \texttt{intmap}, wrapping a function
proxy around the original value.

Now, when checking \texttt{(intmap inc [1 2 3])}, the \texttt{inc} function is
called several hundred times with generated values conforming to \texttt{int?},
and checks each call returns an \texttt{int?}.
Then, \texttt{[1 2 3]} is eagerly checked against \texttt{(s/coll-of int?)}.
The original \texttt{intmap} function is then called with the original arguments,
yielding a value \texttt{(1 2 3)}. Instrumentation does not check return value specs,
so \texttt{(s/coll-of int?)} is ignored, and the original return value is passed to the calling
context.

\subsection{Research questions}

I aim to answer these research questions:

\begin{itemize}
  \item What does the frequency and applications of \texttt{fdef} and \texttt{fspec} specs
    in open source software reveal about the utility of \texttt{clojure.spec}'s
    function semantics in practice?
\end{itemize}

I do not attempt to answer the following questions, which I hypothesize are

\begin{itemize}
  \item How frequently do users instrument specs for runtime verification?
\end{itemize}

\subsection{Methodology}

\subsubsection{Sources}

To determine the frequency of \texttt{fdef} and \texttt{fspec} specs,
the search features of \texttt{GitHub}~\footnote{\texttt{https://github.com}} and 
\texttt{CrossClj}~\footnote{\texttt{https://crossclj.info}} were used.

GitHub indexes tens of thousands of open source Clojure projects, and provides
a rudimentary search interface that is sufficient for discovering textual occurrences 
of functions and macros. False positives are common however, such as
GitHub does not distinguish
between ``toy'' projects and those with official releases, so we remove the former manually.
This is because toy projects do not give a good indication of real-world idioms---for example,
hundreds of projects simply contain experiments with \texttt{clojure.spec} that
are not officially released or maintained.

CrossClj maintains a rich database of cross-links between Clojure projects.
As of Febuary 2018, it indexes 9,438 projects, all of which have official releases (unlike
GitHub search) and thus have more credibility that they are used.
Cross-links are gathered for function/macro usages, and transitive project dependencies.
CrossClj also distinguishes between ClojureScript and Clojure code

\subsubsection{Frequency Data gathering}

Simple GitHub searches were used to find occurrences of \texttt{fdef} and \texttt{fspec}.
As of March 2018,
searches for \texttt{fdef}
yield around 2,000 results~\footnote{\texttt{https://github.com/search?q=fdef+language\%3Aclojure\&type=Code}},
and for \texttt{fspec} 
\footnote{\texttt{https://github.com/search?q=fspec+language\%3Aclojure\&type=Code}}
yield around 600 results.
Searches were quite noisy, so less actual examples of these forms were found.

CrossClj function/macro cross-links were used to find occurrences of spec idioms.
From the latest index (updated February 20th 2018)
\texttt{fdef} occurs in 721 top-level forms over 83 
projects~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/fdef.html}}, and
\texttt{fspec} occurs in 22 top-level forms over 8 
projects~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/fspec.html}}
(the mode number of occurrences per project was 1).

An error was found in the CrossClj data, however.
To find a baseline number of projects using \texttt{clojure.spec}, we looked for occurrences of
\texttt{s/def}, used to define spec
aliases. It should greatly outnumber the number of \texttt{fdef}'s in the ecosystem---we were
surprised to find CrossClj reports the opposite.
We identified that multiple occurrences of \texttt{s/def} in the same project are not always counted by CrossClj,
so while CrossClj claims \texttt{s/def} occurs in more 60\% more projects than \texttt{fdef} (125), 
CrossClj reports \texttt{s/def} only occurs in 349 top-level 
forms~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/def.html}}.
The latter number is too low---CrossClj reports, for example, the \texttt{clj-time}
library only has 2 occurrences of \texttt{s/def}, but it actually has 7 occurrences.

We did not notice such an error in the counts for \texttt{fspec} and \texttt{fdef}, but
this error reduces confidence on the exact numbers. Interestingly, the \emph{relative}
numbers of projects using these forms matches our intuition---\texttt{fspec} occurs
10 times less often than \texttt{fdef}, and \texttt{fdef} occurs about half as often as \texttt{s/def}.
Still, these numbers should be treated with suspicion.

\subsubsection{Project Samples}

We selected 18 open source projects that use \texttt{fspec} to manually examine.
They were chosen by first searching GitHub for \texttt{fspec} occurrences, and
manually choosing the first few dozen results, manually keeping only projects
seemed to have official releases.
Figure~\ref{fspectable} summarizes these findings. We have included the projects
names and our scratch notes as Appendix~\label{appendix1}.

We also searched for negative examples of \texttt{fspec} usage---that is, occurrences
of higher-order functions with specs that did not use \texttt{fspec}---by searching for
both \texttt{fdef} and 
\texttt{ifn?}~\footnote{\texttt{https://github.com/search?utf8=\%E2\%9C\%93\&q=ifn\%3F+fdef+language\%3Aclojure\&type=Code}}, 
the flat contract for Clojure functions.
Several dozen candidates were selecting using a similar method via GitHub search.
We have included the projects
names and our scratch notes as Appendix~\label{appendix2}.

\subsection{What spec features are used in real systems}

\subsection{How precise are spec annotations in practice?}

\subsection{How frequently are higher-order functions annotated with higher-order specs? Why?}

\begin{figure*}[t]

\begin{tabular}{lll}
      \toprule
  & \texttt{fspec} & \texttt{ifn?} \\
  \midrule
  Total occurrences in \texttt{fdef} & 79 & 3 \\
  \tabitem
  Total occurrences in \texttt{fdef} arguments & 65 (82\%) & 3 \\
  \tabitem
  Total occurrences in \texttt{fdef} return & 14  (18\%) & 0 \\
  Total occurrences in map spec & 41 & 2 \\
  \tabitem
  Total occurrences in heterogeneous map spec & 40 & 2 \\
  \tabitem
  Total occurrences in homogenous map spec & 1 & 0 \\

\end{tabular}
\caption{Function specs in practice, in 18 open source projects sourced from
  GitHub that utilized \texttt{fspec}. }
\label{fspectable}
\end{figure*}

Our first investigation concentrated on projects that use \texttt{fspec}.
We chose 18 open source projects and manually investigated their usage of spec.

To guage how \texttt{fspec}s are used in practice, we divided their occurrences
into several categories. 
Figure~\ref{fspectable} presents the results.

First, we measure how many times \texttt{fspec} occurs in top-level function
specs (i.e., \texttt{fdef} forms). Because spec has different semantics for
checking the argument and return of top-level function specs, we split this
category into occurrences in the arguments spec and return spec.
We also similarly measure the occurrences of \texttt{ifn?} in these projects.

We found 82\% \texttt{fspec} instances occuring in the argument position,
with 18\% in the return position.

Clojure.spec instrumentation does not check the return values from functions.

"Note that the :ret and :fn specs are not checked with instrumentation as validating the implementation should occur at testing time."

% function nesting:
% - lens library had largest nesting
% - depth 3 fspec's
% - depth 2 fspec's + terminating ifn?

\subsection{How frequently are higher-order functions not annotated with higher-order specs?}


\subsection{Conclusions}

% how does no polymorphism interact with fspec semantics? are they more useful together?
