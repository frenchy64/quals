\section{Question 2}

\begin{verbatim}
Examine the use of Clojure's core.spec contract system in several
real world code bases. Look at what features are used, and how precise
specifications are. Analyze how specifications address the lack of
higher-order contracts by looking at the frequency of higher-order function
contracts vs higher-order functions that omit specifications of higher-order
arguments or results.
\end{verbatim}

\subsection{clojure.spec}

Recently, Clojure added a runtime verification system to its core library called
\texttt{clojure.spec}.
It resembles common approaches to runtime verification, such as Racket's contract
system, but is different in several important ways.

Firstly, \texttt{clojure.spec} is designed to treat most values as ``data at rest''. That is,
at verification sites, values are eagerly traversed without waiting to see
if or how the program actually uses them.
When we consider that \texttt{clojure.spec} treats infinite streams
and functions as data at rest, we begin to see the tradeoffs that have been
made.

Secondly, specifications (called ``specs'') are not enforced by default. Users must
opt-in to enforcing specs via an explicit instrumentation phase.
This is also different than most contract systems, many of which are enforced
by default. There is no standard way to integrate spec enforcement into a
test suite, so it is difficult to tell whether specific specs are primarily 
unchecked documentation, or actually used for runtime verification.

Since \texttt{clojure.spec} has a unique feature set amongst runtime verification
libraries, it is interesting to consider how programmers use \texttt{clojure.spec}
in practice. For example, do programmers find the semantics of treating functions
as data at rest useful?

Unfortunately, specs are opt-in with non-standard hooks, so it is difficult to
correlate someone writing a spec with that person \emph{using} the spec, which
would imply the person finding the spec's semantics useful.
Nevertheless, in the following sections we attempt to draw conclusions about
spec's common usage based mostly on the frequency of spec annotations.

\subsection{Function specifications in clojure.spec}

From here, we map the namespace prefix \texttt{s} to \texttt{clojure.spec.alpha},
and \texttt{stest} to \texttt{clojure.spec.test.alpha}.

\begin{verbatim}
(require '[clojure.spec.alpha :as s])
\end{verbatim}

There are two kinds of function checking semantics in \texttt{clojure.spec}.
We use \texttt{intmap}, a higher-order function that maps a function over 
a collection of ints, to demonstrate both semantics.

\begin{verbatim}
(defn intmap
  "Maps a collection of ints over a function."
  [f c]
  (map f c))
\end{verbatim}

If the programmer wants to write a higher-order function spec to
verify \texttt{intmap}, they might write the following spec.

\begin{verbatim}
(s/fdef intmap
  :args (s/cat :f (s/fspec :args (cat :x int?) :ret int?)
               :c (s/coll-of int?))
  :ret (s/coll-of int?))
\end{verbatim}

The \texttt{s/fdef} form signals we are annotating a top-level
function, in this case \texttt{intmap}. Argument specs are
provided with the \texttt{:args} keyword option
in the form of the ``tagged'' heterogeneous collection spec
\texttt{s/cat}---here 2 arguments are allowed, tagged as
\texttt{:f} for the function and \texttt{:c} as the collection.

The \texttt{s/fspec} spec is another kind of function spec,
specifically for non-top-level functions (like function arguments
to top-level functions). It has a similar syntax to \texttt{s/fdef},
but a function name is not provided.

In a nutshell, \texttt{s/fdef} provides traditional proxy-based
verification semantics while \texttt{s/fspec} uses eager \emph{generative testing}
to exercise a function before letting it pass the spec boundary, bare (without a proxy).

We will now demonstrate how the following call gets checked.

\begin{verbatim}
(intmap inc [1 2 3])
;=> (2 3 4)
\end{verbatim}

First, the programmer instruments \texttt{intmap} with:

\begin{verbatim}
(stest/instrument `intmap)
\end{verbatim}

This mutates the top-level binding associated with \texttt{intmap}, wrapping a function
proxy around the original value.

Now, when checking \texttt{(intmap inc [1 2 3])}, the \texttt{inc} function is
called several hundred times with generated values conforming to \texttt{int?},
and checks each call returns an \texttt{int?}.
Then, \texttt{[1 2 3]} is eagerly checked against \texttt{(s/coll-of int?)}.
The original \texttt{intmap} function is then called with the original arguments,
yielding a value \texttt{(1 2 3)}. Instrumentation does not check return value specs,
so \texttt{(s/coll-of int?)} is ignored, and the original return value is passed to the calling
context.

\subsection{Research questions}

I aim to answer these research questions:

\begin{itemize}
  \item What does the frequency and applications of \texttt{fdef} and \texttt{fspec} specs
    in open source software reveal about the utility of \texttt{clojure.spec}'s
    function semantics in practice?
\end{itemize}

I do not attempt to answer the following questions, which I hypothesize are

\begin{itemize}
  \item How frequently do users instrument specs for runtime verification?
\end{itemize}

\subsection{Methodology}

\subsubsection{Sources}

To determine the frequency of \texttt{fdef} and \texttt{fspec} specs,
the search features of \texttt{GitHub}~\footnote{\texttt{https://github.com}} and 
\texttt{CrossClj}~\footnote{\texttt{https://crossclj.info}} were used.

GitHub indexes tens of thousands of open source Clojure projects, and provides
a rudimentary search interface that is sufficient for discovering textual occurrences 
of functions and macros. False positives are common however, such as
GitHub does not distinguish
between ``toy'' projects and those with official releases, so we remove the former manually.
This is because toy projects do not give a good indication of real-world idioms---for example,
hundreds of projects simply contain experiments with \texttt{clojure.spec} that
are not officially released or maintained.

CrossClj maintains a rich database of cross-links between Clojure projects.
As of Febuary 2018, it indexes 9,438 projects, all of which have official releases (unlike
GitHub search) and thus have more credibility that they are used.
Cross-links are gathered for function/macro usages, and transitive project dependencies.
CrossClj also distinguishes between ClojureScript and Clojure code

\subsubsection{Frequency Data gathering}

Simple GitHub searches were used to find occurrences of \texttt{fdef} and \texttt{fspec}.
As of March 2018,
searches for \texttt{fdef}
yield around 2,000 results~\footnote{\texttt{https://github.com/search?q=fdef+language\%3Aclojure\&type=Code}},
and for \texttt{fspec} 
\footnote{\texttt{https://github.com/search?q=fspec+language\%3Aclojure\&type=Code}}
yield around 600 results.
Searches were quite noisy, so less actual examples of these forms were found.

CrossClj function/macro cross-links were used to find occurrences of spec idioms.
From the latest index (updated February 20th 2018)
\texttt{fdef} occurs in 721 top-level forms over 83 
projects~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/fdef.html}}, and
\texttt{fspec} occurs in 22 top-level forms over 8 
projects~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/fspec.html}}
(the mode number of occurrences per project was 1).

An error was found in the CrossClj data, however.
To find a baseline number of projects using \texttt{clojure.spec}, we looked for occurrences of
\texttt{s/def}, used to define spec
aliases. It should greatly outnumber the number of \texttt{fdef}'s in the ecosystem---we were
surprised to find CrossClj reports the opposite.
We identified that multiple occurrences of \texttt{s/def} in the same project are not always counted by CrossClj,
so while CrossClj claims \texttt{s/def} occurs in more 60\% more projects than \texttt{fdef} (125), 
CrossClj reports \texttt{s/def} only occurs in 349 top-level 
forms~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/def.html}}.
The latter number is too low---CrossClj reports, for example, the \texttt{clj-time}
library only has 2 occurrences of \texttt{s/def}, but it actually has 7 occurrences.

We did not notice such an error in the counts for \texttt{fspec} and \texttt{fdef}, but
this error reduces confidence on the exact numbers. Interestingly, the \emph{relative}
numbers of projects using these forms matches our intuition---\texttt{fspec} occurs
10 times less often than \texttt{fdef}, and \texttt{fdef} occurs about half as often as \texttt{s/def}.
Still, these numbers should be treated with suspicion.

\subsubsection{Project Samples}

We selected 18 open source projects that use \texttt{fspec} to manually examine.
They were chosen by first searching GitHub for \texttt{fspec} occurrences, and
manually choosing the first few dozen results, manually keeping only projects
seemed to have official releases.
Figure~\ref{fspectable} summarizes these findings. We have included the project
names and our scratch notes as Appendix~\label{appendix1}.

We also searched for negative examples of \texttt{fspec} usage---that is, occurrences
of higher-order functions with specs that did not use \texttt{fspec}---by searching for
both \texttt{fdef} and 
\texttt{ifn?}~\footnote{\texttt{https://github.com/search?utf8=\%E2\%9C\%93\&q=ifn\%3F+fdef+language\%3Aclojure\&type=Code}}, 
the flat contract for Clojure functions.
Several dozen candidates were selecting using a similar method via GitHub search.
Appendix~\label{appendix2} contains the projects and our scratch notes for this experiment.

\subsection{What spec features are used in real systems}

\subsection{How precise are spec annotations in practice?}

\subsection{How frequently are higher-order functions annotated with higher-order specs? Why?}

\begin{figure*}[t]

\begin{tabular}{lll}
      \toprule
  & \texttt{fspec} & \texttt{ifn?} \\
  \midrule
  Total occurrences in \texttt{fdef} & 79 & 3 \\
  \tabitem
  Total occurrences in \texttt{fdef} arguments & 65 (82\%) & 3 \\
  \tabitem
  Total occurrences in \texttt{fdef} return & 14  (18\%) & 0 \\
  Total occurrences in map spec & 41 & 2 \\
  \tabitem
  Total occurrences in heterogeneous map spec & 40 (97\%) & 2 \\
  \tabitem
  Total occurrences in homogenous map spec & 1 (3\%) & 0 \\

\end{tabular}
\caption{Function specs in practice, in 18 open source projects sourced from GitHub that utilized \texttt{fspec}. }
\label{fspectable}
\end{figure*}

Our first investigation concentrated on projects that use \texttt{fspec}.
We chose 18 open source projects and manually investigated their usage of spec.

To guage how \texttt{fspec}s are used in practice, we divided their occurrences
into several categories. 
Figure~\ref{fspectable} presents the results.

First, we measure how many times \texttt{fspec} occurs in top-level function
specs (i.e., \texttt{fdef} forms). Because spec has different semantics for
checking the argument and return of top-level function specs, we split this
category into occurrences in the arguments spec and return spec.
We also similarly measure the occurrences of \texttt{ifn?} in these projects,
which was sparsely used in these projects.

We found 82\% \texttt{fspec} instances occuring in the argument position,
with 18\% in the return position.

Second, we measure the frequency of \texttt{fspec} in a hash-map spec.
Of the occurrences of \texttt{fspec} in map specifications, 
we found a strong preference for using heterogenous map specs (97\%),
with the rest being homogeneous maps.
Similar to the previous experiment, the flat function contract \texttt{ifn?} was rarely used 
in map specs in these projects.

We noticed several interesting things while conducting these experiments.

There was only 2 occurrence of nesting function specs more than 2 deep---in a library
that provides functional lenses~\footnote{https://github.com/andrewmcveigh/bifocal}.
Of those, one used 3 \texttt{fspec}s, the other 2 \texttt{fspec}s with a terminating \texttt{ifn?}.

We also noticed several users combining \texttt{fspec}s with the \texttt{or} spec
for disjunctions. It's unclear how well this works in practice (and might only be
there for documentation), but the ``looser'' generative testing semantics of \texttt{fspec}
seems to have more compatibility with disjunction contracts than the ``stricter''
proxy-based verification approach.

Spec also provides the ability to write dependent function contracts via the \texttt{:fn}
keyword option of \texttt{fspec}, allowing programmers
to add custom code to verify the relationship between function arguments and return values.
We found several interesting dependent contracts that used surprising techniques like
memoization to verify calls to higher-order functions~\footnote{https://github.com/CharlesHD/chu.graph}.

Some developers explicitly worked around the \texttt{fspec}'s generative testing semantics.
We found several comments and workarounds explaining why \texttt{fspec}s were not
appropriate in particular contexts. Common concerns were
\\
\begin{itemize}
	\item triggering function side effects,
	\item difficultly writing generators for testing the function, and
	\item being unsure whether generative testing was appropriate.
\end{itemize}

We speculate the lack of polymorphic function specs contributed to these concerns.
Since instances of a type variable were replaced with \texttt{any?} specs, writing
a generator often did not make sense. It's unclear whether polymorphic specs are
even feasible to check, but some developers at least seem attached to the documentation
capabilities of \texttt{fspec}, perhaps suggesting more control over the testing
semantics of \texttt{fspec} would be welcomed by spec users.

% function nesting:
% - lens library had largest nesting
% - depth 3 fspec's
% - depth 2 fspec's + terminating ifn?

\subsection{How frequently are higher-order functions not annotated with higher-order specs?}

\subsection{Conclusions}

Clojure.spec instrumentation does not check the return values from functions.

"Note that the :ret and :fn specs are not checked with instrumentation as validating the implementation should occur at testing time."

% how does no polymorphism interact with fspec semantics? are they more useful together?
