\section{Question 2}

\begin{verbatim}
Examine the use of Clojure's core.spec contract system in several
real world code bases. Look at what features are used, and how precise
specifications are. Analyze how specifications address the lack of
higher-order contracts by looking at the frequency of higher-order function
contracts vs higher-order functions that omit specifications of higher-order
arguments or results.
\end{verbatim}

% arachne-pedestal: not fit for public consumption
% https://github.com/arachne-framework/arachne-pedestal/blob/a0a21092063ae74c311566a10f8f14cf8756c7c9/src/arachne/pedestal/specs.clj

% valuehash: fn returning fn
% https://github.com/arachne-framework/valuehash/blob/fdd19b4a4c3b294d46fe7e0b50187290043b48aa/src/valuehash/specs.clj

% arachne-fileset: 
% https://github.com/arachne-framework/arachne-fileset/blob/0336d2d8d273eb1e0a862641000da1bd76099626/test/user.clj#L35

% dspec: utility function, checks direct HOF
% https://github.com/lab-79/dspec/blob/26f88e74066e381c8569d175c1bd5948a8005bd0/src/clj/lab79/dspec/util.clj

% async-connect: maps of fn handlers
% https://github.com/tyano/async-connect/blob/4f30801485b68e60fc5352b8a169b6f5829d2553/src/async_connect/netty/handler.clj

% async-connect: maps of fn's (channel ops)
% https://github.com/tyano/async-connect/blob/4f30801485b68e60fc5352b8a169b6f5829d2553/src/async_connect/server.clj#L46

% knotation: maps of fn's
% https://github.com/knotation/knotation-cljc/blob/e3ed2722adc9e87d815066be55636017e6a9c30f/spec/org/knotation/format_spec.cljc#L11

% devcards: direct HOF, also mixes ifn? checks
% https://github.com/olivergeorge/devcards-vs-clojure-spec/blob/385e332c21e57b097b56e899c09e99a260daf3ad/src/devcards_vs_clojure_spec/core_specs.cljc#L7

% sandbox: spec for fn returning (dependent) fn
% https://github.com/dantheobserver/sandbox/blob/955202b5d3e9f6bbb4bae2169f9b527210d5ef81/src/sandbox/observable.clj#L5

% email-tool: map of fn's
% https://github.com/andrewzhurov/email-tool/blob/fd6bf979c5534315edf0d5e2ca762a879d0c9587/src/email_tool/parts.clj#L8

% dcsite: map of fn's (react event handlers)
% https://github.com/daveconservatoire/dcsite-cljs/blob/f02e31c081d8dc1d7b1913a0b7f6906bbc0b5824/src/cljs/daveconservatoire/support/specs.cljs#L47

% chejoobot: fn returning fn
% https://github.com/chejoo-platform/chejoobot-clj/blob/922fdadd6dd58a62ca07d9c350764d0719322d2d/src/chejoobot/handlers/filters.clj#L9
% chejoobot: map of fn
% https://github.com/chejoo-platform/chejoobot-clj/blob/922fdadd6dd58a62ca07d9c350764d0719322d2d/src/chejoobot/handlers/core.clj#L35

% bifocal: lenses, everything is HOF, sorely missing polymorphism
% https://github.com/andrewmcveigh/bifocal/blob/850e79452f4f9bc6966768055acfc7aae6671f80/src/bifocal/lens.clj#L36

% triboard: fn taking fn
% https://github.com/QuentinDuval/triboard/blob/dc9d60197262857bbea0756a5a395ba248929961/src/cljs/triboard/view/frame.cljs#L15

% yoose: fn taking handler fn
% https://github.com/brianium/yoose/blob/6400ed9e20f8472411c6cb0185a392cda097a0b8/src/brianium/yoose/spec.clj#L9

% cljs-fn: map of fn's
% https://github.com/briansunter/cljs-hn/blob/a15bac4535fd88d6f79a80864a0301fe3d7d8d60/src/hackernews/components/list.cljs#L15

% kxix.collect: fn taking handler/processing fn's
% https://github.com/MastodonC/kixi.collect/blob/8a5e6a0de041f5684602235be6466afa805be92d/src/kixi/collect/aggregate.clj#L15

% frereth-common: or + fn's !!!
% https://github.com/jimrthy/frereth-common/blob/ff59081b170984d25e8e8192d34348ce36f7296c/src/com/frereth/common/methods.cljc#L33-L36

% ring-spec: fn taking callback fn
% https://github.com/mpenet/ring-spec/blob/f7db868d8e6facab72c3cba925bf7c12496c1a36/src/clj/qbits/ring_spec.clj#L85

% datomic-spec: homogeneous map with fn vals
% https://github.com/lab-79/datomic-spec/blob/880ab123b49da8cc79c27cd78c9a2455b260e4b9/src/cljc/lab79/datomic_spec/gen_overrides.cljc#L6

% frereth-client: map with fn's
% https://github.com/jimrthy/frereth-client/blob/39d0be51a1337eac7b5645be3bbb0a598c17eb53/src/com/frereth/client/repl.clj#L11

% slide: fn taking fn
% https://github.com/saulshanabrook/slide/blob/77e5c40e17db276ebcd7924e3a9d292e69231e16/src/examples/stats.clj#L62

% mqtt: many fspecs, contain very specific args
% https://github.com/dvlopt/mqtt/blob/c7f2dcaf8d4df0a31460c16f24c5b402f21df655/src/dvlopt/mqtt/v3.clj

% frereth-common: takes and returns fn
% https://github.com/jimrthy/frereth-common/blob/88e57bb942334124f29be1b9405bbf04c9c2af08/src/com/frereth/common/aleph.clj#L98

% chu.graph: fn returning fn
% https://github.com/CharlesHD/chu.graph/blob/a820ef8456b44b1044d7f6cd9340a5504ad393de/src/chu/graph.cljc#L17

% takelist: fn returning fn
% https://github.com/alexanderkiel/takelist/blob/434ef6f6e05ca406c446b81fa5a77c7f0519c355/src/takelist/app.clj#L27

% java.jdbc: seems dubious these are ever used, unless fn's are stubbed.
% https://github.com/clojure/java.jdbc/blob/64a79366fa464be75bdf4bdda133441b9d1efb26/src/main/clojure/clojure/java/jdbc/spec.clj#L124

% sparkle: disjunction between map and fn
% https://github.com/GradySimon/sparkle/blob/d5d82c37ab6be8359be7d3b5524d8b32dac452a1/src/sparkle/spec.clj#L18-L24

\subsection{clojure.spec}

Recently, Clojure added a runtime verification system to its core library called
\texttt{clojure.spec}.
It resembles common approaches to runtime verification, such as Racket's contract
system, but is different in several important ways.

Firstly, \texttt{clojure.spec} is designed to treat most values as ``data at rest''. That is,
at verification sites, values are eagerly traversed without waiting to see
if or how the program actually uses them.
When we consider that \texttt{clojure.spec} treats infinite streams
and functions as data at rest, we begin to see the tradeoffs that have been
made.

Secondly, specifications (called ``specs'') are not enforced by default. Users must
opt-in to enforcing specs via an explicit instrumentation phase.
This is also different than most contract systems, many of which are enforced
by default. There is no standard way to integrate spec enforcement into a
test suite, so it is difficult to tell whether specific specs are primarily 
unchecked documentation, or actually used for runtime verification.

Since \texttt{clojure.spec} has a unique feature set amongst runtime verification
libraries, it is interesting to consider how programmers use \texttt{clojure.spec}
in practice. For example, do programmers find the semantics of treating functions
as data at rest useful?

Unfortunately, specs are opt-in with non-standard hooks, so it is difficult to
correlate someone writing a spec with that person \emph{using} the spec, which
would imply the person finding the spec's semantics useful.
Nevertheless, in the following sections we attempt to draw conclusions about
spec's common usage based mostly on the frequency of spec annotations.

\subsection{Function specifications in clojure.spec}

From here, we map the namespace prefix \texttt{s} to \texttt{clojure.spec.alpha},
and \texttt{stest} to \texttt{clojure.spec.test.alpha}.

\begin{verbatim}
(require '[clojure.spec.alpha :as s])
\end{verbatim}

There are two kinds of function checking semantics in \texttt{clojure.spec}.
We use \texttt{intmap}, a higher-order function that maps a function over 
a collection of ints, to demonstrate both semantics.

\begin{verbatim}
(defn intmap
  "Maps a collection of ints over a function."
  [f c]
  (map f c))
\end{verbatim}

If the programmer wants to write a higher-order function spec to
verify \texttt{intmap}, they might write the following spec.

\begin{verbatim}
(s/fdef intmap
  :args (s/cat :f (s/fspec :args (cat :x int?) :ret int?)
               :c (s/coll-of int?))
  :ret (s/coll-of int?))
\end{verbatim}

The \texttt{s/fdef} form signals we are annotating a top-level
function, in this case \texttt{intmap}. Argument specs are
provided with the \texttt{:args} keyword option
in the form of the ``tagged'' heterogeneous collection spec
\texttt{s/cat}---here 2 arguments are allowed, tagged as
\texttt{:f} for the function and \texttt{:c} as the collection.

The \texttt{s/fspec} spec is another kind of function spec,
specifically for non-top-level functions (like function arguments
to top-level functions). It has a similar syntax to \texttt{s/fdef},
but a function name is not provided.

In a nutshell, \texttt{s/fdef} provides traditional proxy-based
verification semantics while \texttt{s/fspec} uses eager \emph{generative testing}
to exercise a function before letting it pass the spec boundary, bare (without a proxy).

We will now demonstrate how the following call gets checked.

\begin{verbatim}
(intmap inc [1 2 3])
;=> (2 3 4)
\end{verbatim}

First, the programmer instruments \texttt{intmap} with:

\begin{verbatim}
(stest/instrument `intmap)
\end{verbatim}

This mutates the top-level binding associated with \texttt{intmap}, wrapping a function
proxy around the original value.

Now, when checking \texttt{(intmap inc [1 2 3])}, the \texttt{inc} function is
called several hundred times with generated values conforming to \texttt{int?},
and checks each call returns an \texttt{int?}.
Then, \texttt{[1 2 3]} is eagerly checked against \texttt{(s/coll-of int?)}.
The original \texttt{intmap} function is then called with the original arguments,
yielding a value \texttt{(1 2 3)}. This value is then eagerly checked against
\texttt{(s/coll-of int?)}, and the original return value is passed to the calling
context.

\subsection{Research questions}

I aim to answer these research questions:

\begin{itemize}
  \item What does the frequency and applications of \texttt{fdef} and \texttt{fspec} specs
    in open source software reveal about the utility of \texttt{clojure.spec}'s
    function semantics in practice?
\end{itemize}

I do not attempt to answer the following questions, which I hypothesize are

\begin{itemize}
  \item How frequently do users instrument specs for runtime verification?
\end{itemize}

\subsection{Methodology}

\subsubsection{Sources}

To determine the frequency of \texttt{fdef} and \texttt{fspec} specs,
the search features of \texttt{GitHub}~\footnote{\texttt{https://github.com}} and 
\texttt{CrossClj}~\footnote{\texttt{https://crossclj.info}} were used.

GitHub indexes tens of thousands of open source Clojure projects, and provides
a rudimentary search interface that is sufficient for discovering textual occurrences 
of functions and macros.
GitHub does not distinguish
between ``toy'' projects and those with official releases, so we remove the former manually.
This is because toy projects do not give a good indication of real-world idioms---for example,
hundreds of projects simply contain experiments with \texttt{clojure.spec} that
are not offically released or maintained.

CrossClj maintains a rich database of cross-links between Clojure projects.
As of Febuary 2018, it indexes 9,438 projects, all of which have official releases (unlike
GitHub search) and thus have more credibility that they are used.
Cross-links are gathered for function/macro usages, and transitive project dependencies.
CrossClj also distinguishes between ClojureScript and Clojure code

\subsubsection{Data gathering}

Simple GitHub searches were used to find occurrences of \texttt{fdef} and \texttt{fspec}.
As of March 2018,
searches for \texttt{fdef}
yield around 2,000 results~\footnote{\texttt{https://github.com/search?q=fdef+language\%3Aclojure\&type=Code}},
and for \texttt{fspec} 
\footnote{\texttt{https://github.com/search?q=fspec+language\%3Aclojure\&type=Code}}
yield around 600 results.

CrossClj function/macro 

\subsection{}

\subsection{What spec features are used in real systems}

\subsection{How precise are spec annotations in practice?}

\subsection{How frequently are higher-order functions annotated with higher-order specs? Why?}

\subsection{How frequently are higher-order functions not annotated with higher-order specs?}

\subsection{Conclusions}

% how does no polymorphism interact with fspec semantics? are they more useful together?
