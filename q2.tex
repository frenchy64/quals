\section{Question 2}

\begin{verbatim}
Examine the use of Clojure's core.spec contract system in several
real world code bases. Look at what features are used, and how precise
specifications are. Analyze how specifications address the lack of
higher-order contracts by looking at the frequency of higher-order function
contracts vs higher-order functions that omit specifications of higher-order
arguments or results.
\end{verbatim}

\subsection{clojure.spec}

Recently, Clojure added a runtime verification system to its core library called
\texttt{clojure.spec}.
It resembles common approaches to runtime verification, such as Racket's contract
system, but is different in several important ways.

Firstly, \texttt{clojure.spec} is designed to treat most values as ``data at rest''. That is,
at verification sites, values are eagerly traversed without waiting to see
if or how the program actually uses them.
When we consider that \texttt{clojure.spec} treats infinite streams
and functions as data at rest, we begin to see the tradeoffs that have been
made.

Secondly, specifications (called ``specs'') are not enforced by default. Users must
opt-in to enforcing specs via an explicit instrumentation phase.
This is also different than most contract systems, many of which are enforced
by default. There is no standard way to integrate spec enforcement into a
test suite, so it is difficult to tell whether specific specs are primarily 
unchecked documentation, or actually used for runtime verification.

Since \texttt{clojure.spec} has a unique feature set amongst runtime verification
libraries, it is interesting to consider how programmers use \texttt{clojure.spec}
in practice. For example, do programmers find the semantics of treating functions
as data at rest useful?

Unfortunately, specs are opt-in with non-standard hooks, so it is difficult to
correlate someone writing a spec with that person \emph{using} the spec, which
would imply the person finding the spec's semantics useful.
Nevertheless, in the following sections we attempt to draw conclusions about
spec's common usage based mostly on the frequency of spec annotations.

\subsection{Function specifications in clojure.spec}

From here, we map the namespace prefix \texttt{s} to \texttt{clojure.spec.alpha},
and \texttt{stest} to \texttt{clojure.spec.test.alpha}.

\begin{verbatim}
(require '[clojure.spec.alpha :as s])
\end{verbatim}

There are two kinds of function checking semantics in \texttt{clojure.spec}.
We use \texttt{intmap}, a higher-order function that maps a function over 
a collection of ints, to demonstrate both semantics.

\begin{verbatim}
(defn intmap
  "Maps a collection of ints over a function."
  [f c]
  (map f c))
\end{verbatim}

If the programmer wants to write a higher-order function spec to
verify \texttt{intmap}, they might write the following spec.

\begin{verbatim}
(s/fdef intmap
  :args (s/cat :f (s/fspec :args (cat :x int?) :ret int?)
               :c (s/coll-of int?))
  :ret (s/coll-of int?))
\end{verbatim}

The \texttt{s/fdef} form signals we are annotating a top-level
function, in this case \texttt{intmap}. Argument specs are
provided with the \texttt{:args} keyword option
in the form of the ``tagged'' heterogeneous collection spec
\texttt{s/cat}---here 2 arguments are allowed, tagged as
\texttt{:f} for the function and \texttt{:c} as the collection.

The \texttt{s/fspec} spec is another kind of function spec,
specifically for non-top-level functions (like function arguments
to top-level functions). It has a similar syntax to \texttt{s/fdef},
but a function name is not provided.

In a nutshell, \texttt{s/fdef} provides traditional proxy-based
verification semantics while \texttt{s/fspec} uses eager \emph{generative testing}
to exercise a function before letting it pass the spec boundary, bare (without a proxy).

We will now demonstrate how the following call gets checked.

\begin{verbatim}
(intmap inc [1 2 3])
;=> (2 3 4)
\end{verbatim}

First, the programmer instruments \texttt{intmap} with:

\begin{verbatim}
(stest/instrument `intmap)
\end{verbatim}

This mutates the top-level binding associated with \texttt{intmap}, wrapping a function
proxy around the original value.

Now, when checking \texttt{(intmap inc [1 2 3])}, the \texttt{inc} function is
called several hundred times with generated values conforming to \texttt{int?},
and checks each call returns an \texttt{int?}.
Then, \texttt{[1 2 3]} is eagerly checked against \texttt{(s/coll-of int?)}.
The original \texttt{intmap} function is then called with the original arguments,
yielding a value \texttt{(1 2 3)}. This value is then eagerly checked against
\texttt{(s/coll-of int?)}, and the original return value is passed to the calling
context.

\subsection{Research questions}

I aim to answer these research questions:

\begin{itemize}
  \item What does the frequency and applications of \texttt{fdef} and \texttt{fspec} specs
    in open source software reveal about the utility of \texttt{clojure.spec}'s
    function semantics in practice?
\end{itemize}

I do not attempt to answer the following questions, which I hypothesize are

\begin{itemize}
  \item How frequently do users instrument specs for runtime verification?
\end{itemize}

\subsection{Methodology}

\subsubsection{Sources}

To determine the frequency of \texttt{fdef} and \texttt{fspec} specs,
the search features of \texttt{GitHub}~\footnote{\texttt{https://github.com}} and 
\texttt{CrossClj}~\footnote{\texttt{https://crossclj.info}} were used.

GitHub indexes tens of thousands of open source Clojure projects, and provides
a rudimentary search interface that is sufficient for discovering textual occurrences 
of functions and macros. False positives are common however, such as
GitHub does not distinguish
between ``toy'' projects and those with official releases, so we remove the former manually.
This is because toy projects do not give a good indication of real-world idioms---for example,
hundreds of projects simply contain experiments with \texttt{clojure.spec} that
are not officially released or maintained.

CrossClj maintains a rich database of cross-links between Clojure projects.
As of Febuary 2018, it indexes 9,438 projects, all of which have official releases (unlike
GitHub search) and thus have more credibility that they are used.
Cross-links are gathered for function/macro usages, and transitive project dependencies.
CrossClj also distinguishes between ClojureScript and Clojure code

\subsubsection{Frequency Data gathering}

Simple GitHub searches were used to find occurrences of \texttt{fdef} and \texttt{fspec}.
As of March 2018,
searches for \texttt{fdef}
yield around 2,000 results~\footnote{\texttt{https://github.com/search?q=fdef+language\%3Aclojure\&type=Code}},
and for \texttt{fspec} 
\footnote{\texttt{https://github.com/search?q=fspec+language\%3Aclojure\&type=Code}}
yield around 600 results.
Searches were quite noisy, so less actual examples of these forms were found.

CrossClj function/macro cross-links were used to find occurrences of spec idioms.
From the latest index (updated February 20th 2018)
\texttt{fdef} occurs in 721 top-level forms over 83 
projects~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/fdef.html}}, and
\texttt{fspec} occurs in 22 top-level forms over 8 
projects~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/fspec.html}}
(the mode number of occurrences per project was 1).

An error was found in the CrossClj data, however.
To find a baseline number of projects using \texttt{clojure.spec}, we looked for occurrences of
\texttt{s/def}, used to define spec
aliases. It should greatly outnumber the number of \texttt{fdef}'s in the ecosystem---we were
surprised to find CrossClj reports the opposite.
We identified that multiple occurrences of \texttt{s/def} in the same project are not always counted by CrossClj,
so while CrossClj claims \texttt{s/def} occurs in more 60\% more projects than \texttt{fdef} (125), 
CrossClj reports \texttt{s/def} only occurs in 349 top-level 
forms~\footnote{\texttt{https://crossclj.info/fun/clojure.spec.alpha/def.html}}.
The latter number is too low---CrossClj reports, for example, the \texttt{clj-time}
library only has 2 occurrences of \texttt{s/def}, but it actually has 7 occurrences.

We did not notice such an error in the counts for \texttt{fspec} and \texttt{fdef}, but
this error reduces confidence on the exact numbers. Interestingly, the \emph{relative}
numbers of projects using these forms matches our intuition---\texttt{fspec} occurs
10 times less often than \texttt{fdef}, and \texttt{fdef} occurs about half as often as \texttt{s/def}.
Still, these numbers should be treated with suspicion.

\subsubsection{Project Samples}

We selected several dozen projects that use \texttt{fspec} to manually examine.
They were chosen by first searching GitHub for \texttt{fspec} occurrences, and
manually choosing the first few dozen results, manually keeping only projects
seemed to have official releases.

We also searched for negative examples of \texttt{fspec} usage---that is, occurrences
of higher-order functions with specs that did not use \texttt{fspec}---by searching for
both \texttt{fdef} and 
\texttt{ifn?}~\footnote{\texttt{https://github.com/search?utf8=\%E2\%9C\%93\&q=ifn\%3F+fdef+language\%3Aclojure\&type=Code}}, 
the flat contract for Clojure functions.
Several dozen candidates were selecting using the same method.

\subsection{}

\subsection{What spec features are used in real systems}

\subsection{How precise are spec annotations in practice?}

\subsection{How frequently are higher-order functions annotated with higher-order specs? Why?}

% valuehash: 
% - 1 fn returning fn
% - 1 fn taking fn
% - Note: fn takes input-stream, how to generate? are fspec generators used in `lein test`?
% https://github.com/arachne-framework/valuehash/blob/fdd19b4a4c3b294d46fe7e0b50187290043b48aa/src/valuehash/specs.clj

% arachne-fileset: trying to get best of both worlds (documentation but no generative testing)
% - 1 fn taking pred
% - Note: fn takes File
% https://github.com/arachne-framework/arachne-fileset/blob/0336d2d8d273eb1e0a862641000da1bd76099626/test/user.clj#L35

% dspec: utility function, checks direct HOF
% - 1 fn taking pred (filter wrapper)
% https://github.com/lab-79/dspec/blob/26f88e74066e381c8569d175c1bd5948a8005bd0/src/clj/lab79/dspec/util.clj

% async-connect: maps of fn handlers
% - 19 fspecs, for a `keys` of functions
% - Note: `with-generator` suppresses all fspec generators, but that doesn't suppress
%   instrumentation fn generative testing. Unsure if generative testing used.
%   Takes a :netty/context, but that spec isn't defined anywhere...
% https://github.com/tyano/async-connect/blob/4f30801485b68e60fc5352b8a169b6f5829d2553/src/async_connect/netty/handler.clj
% - 7 fspecs, maps of fn's (channel ops)
% - Note: `with-generator` suppresses generators
% https://github.com/tyano/async-connect/blob/4f30801485b68e60fc5352b8a169b6f5829d2553/src/async_connect/server.clj#L46

% devcards: direct HOF, also mixes ifn? checks
% - 3 ifn?'s
% - 1 fspec
%   - 1 fn returning fn
%   - 1 fn taking map with a fn entry
% - Note: alpha quality
% https://github.com/olivergeorge/devcards-vs-clojure-spec/blob/385e332c21e57b097b56e899c09e99a260daf3ad/src/devcards_vs_clojure_spec/core_specs.cljc#L7

% email-tool: map of fn's
% - 2 fspecs
%   - map args to fn
%   - 1 fspec is any -> any
%   - 1 fspec has easy to generate things (strings etc.)
% https://github.com/andrewzhurov/email-tool/blob/fd6bf979c5534315edf0d5e2ca762a879d0c9587/src/email_tool/parts.clj#L8

% dcsite: map of fn's (react event handlers)
% - 4 fspecs
%   - map of react event fn's
% - Note: do these generate?
% https://github.com/daveconservatoire/dcsite-cljs/blob/f02e31c081d8dc1d7b1913a0b7f6906bbc0b5824/src/cljs/daveconservatoire/support/specs.cljs#L47

% bifocal: lenses, everything is HOF, sorely missing polymorphism
% - 6 fspecs
%   - 4 are basically any -> any
%   - fn taking fn taking fn
%    - (s/def ::upd-f (s/fspec :args (s/cat :s any? :f fn?) :ret any?))
% - 1 fn?
%   - as above, mixing with fspec
% https://github.com/andrewmcveigh/bifocal/blob/850e79452f4f9bc6966768055acfc7aae6671f80/src/bifocal/lens.clj#L36

% triboard: fn taking fn
% - 1 fspec
%   - posn -> any
% https://github.com/QuentinDuval/triboard/blob/dc9d60197262857bbea0756a5a395ba248929961/src/cljs/triboard/view/frame.cljs#L15

% yoose: fn taking handler fn
% - 1 fspec
%   - 1 fn taking fn (any -> any, event handler)
% https://github.com/brianium/yoose/blob/6400ed9e20f8472411c6cb0185a392cda097a0b8/src/brianium/yoose/spec.clj#L9

% cljs-fn: map of fn's
% - 2 fspecs (react)
%   - map of fn's
%   - render db/id fn
%   - thunk for end of row formatting
% https://github.com/briansunter/cljs-hn/blob/a15bac4535fd88d6f79a80864a0301fe3d7d8d60/src/hackernews/components/list.cljs#L15

% kxix.collect: fn taking handler/processing fn's
% - 2 fspecs
%   - 1 fn taking fn's (handlers)
% - Note: alpha, no release but not a toy
% https://github.com/MastodonC/kixi.collect/blob/8a5e6a0de041f5684602235be6466afa805be92d/src/kixi/collect/aggregate.clj#L15

% frereth-common: or + fn's !!!
% - 5 fspecs
%  - odd combination of or + fspec's
%  - most (any -> any) but comments are unsure if it can be more specific
%   - perhaps polymorphism might help?
% - Note: unreleased, discouraged from use, but not a toy
% https://github.com/jimrthy/frereth-common/blob/ff59081b170984d25e8e8192d34348ce36f7296c/src/com/frereth/common/methods.cljc#L33-L36
% - 5 fspecs
%   - 3 fn taking fn (bytes -> any)
%   - 2 fn returning fn
% https://github.com/jimrthy/frereth-common/blob/88e57bb942334124f29be1b9405bbf04c9c2af08/src/com/frereth/common/aleph.clj#L98

% ring-spec: fn taking callback fn
% - 5 fspecs
%  - odd or + fspecs
%    - https://github.com/mpenet/ring-spec/blob/f7db868d8e6facab72c3cba925bf7c12496c1a36/src/clj/qbits/ring_spec.clj#L109-L111
% - Note: are fspecs even used?
% https://github.com/mpenet/ring-spec/blob/f7db868d8e6facab72c3cba925bf7c12496c1a36/src/clj/qbits/ring_spec.clj#L85

% datomic-spec: homogeneous map with fn vals
% - 1 fspec (in testing code)
%   - 1 fn returning homogeneous map of fn vals (thunks that return test.check generators)
% https://github.com/lab-79/datomic-spec/blob/880ab123b49da8cc79c27cd78c9a2455b260e4b9/src/cljc/lab79/datomic_spec/gen_overrides.cljc#L6

% frereth-client: map with fn's
% - 1 fspec (repl shut-down fn)
%   - in config map entry (presumably for fn input, but not used)
%   - However, omitted from actual spec, side effects?
%     - ugh, actually I have no idea what's happening
%     - https://github.com/jimrthy/frereth-client/blob/39d0be51a1337eac7b5645be3bbb0a598c17eb53/src/com/frereth/client/repl.clj#L37-L38
% https://github.com/jimrthy/frereth-client/blob/39d0be51a1337eac7b5645be3bbb0a598c17eb53/src/com/frereth/client/repl.clj#L11

% mqtt: many fspecs, contain very specific args
% - 10 fspecs
%  - 1 fn returning fn (connection init fn)
%  - 1 fn taking fn (handler)
%  - 4 fn map of fn
%  - 1 fspec fn intersection (I (nil Val -> Any) (Val nil -> Any))
%  - 
% https://github.com/dvlopt/mqtt/blob/c7f2dcaf8d4df0a31460c16f24c5b402f21df655/src/dvlopt/mqtt/v3.clj

% chu.graph: fn returning fn
% https://github.com/CharlesHD/chu.graph/blob/a820ef8456b44b1044d7f6cd9340a5504ad393de/src/chu/graph.cljc#L17

% takelist: fn returning fn
% https://github.com/alexanderkiel/takelist/blob/434ef6f6e05ca406c446b81fa5a77c7f0519c355/src/takelist/app.clj#L27

% java.jdbc: seems dubious these are ever used, unless fn's are stubbed.
% https://github.com/clojure/java.jdbc/blob/64a79366fa464be75bdf4bdda133441b9d1efb26/src/main/clojure/clojure/java/jdbc/spec.clj#L124

% sparkle: disjunction between map and fn
% https://github.com/GradySimon/sparkle/blob/d5d82c37ab6be8359be7d3b5524d8b32dac452a1/src/sparkle/spec.clj#L18-L24

\subsection{How frequently are higher-order functions not annotated with higher-order specs?}

% arachne-fileset : explicitly avoids fspec, comments out more expressive specs to avoid generative behaviour
% https://github.com/arachne-framework/arachne-fileset/blob/0336d2d8d273eb1e0a862641000da1bd76099626/src/arachne/fileset/specs.clj#L7

% z-com : uses ifn? (probably polymorphic 1 arg function), probably doesn't make sense to gen
% https://github.com/aw7/z-com/blob/3180acf693f620bde5c7fb9d7c300e5deb02f88a/src/z_com/standard.cljs#L18

% meiro : uses ifn? (unclear how to fspec, might be possible with very specific generators)
% https://github.com/defndaines/meiro/blob/19f93996b87663fec5ed70c4966d114aa4855d6b/src/meiro/backtracker.clj#L17
% - another 3 occurrences of ifn?
% https://github.com/defndaines/meiro/blob/f4fe98f8a54ffd0cc78a671de96bcd9727904c0c/src/meiro/core.clj#L201

% comfy : utility library, uses ifn? for HOF's (19 occurrences in about a dozen very polymorphic function specs)
% https://github.com/madstap/comfy/blob/bbca80f269a912a3a4914188d8dac29e5edaca0b/src/madstap/comfy.cljc
% - 4 more ifn?'s
% https://github.com/madstap/comfy/blob/8c5b43802b8d263abfbbc04f21a7461dcfa08d49/src/madstap/comfy/alpha.cljc

% ferje : polymorphic "app(ly)" function uses ifn?
% https://github.com/chourave/ferje/blob/d8a3261309a994bdbaf6e3af29fc6d22c3e51844/src/ferje/util.clj#L33

% huri : 12 occurrences of ifn? (here combines `s/or` and ifn?, so fspec probably not appropriate)
% https://github.com/sbelak/huri/blob/fc98c5f1870f524c1e2662980085b6a258abd5cf/src/huri/core.clj#L159-L161

% arche : ifn? takes a "User Defined Type" (keyword), perhaps hard to generate?
% https://github.com/troy-west/arche/blob/1c739d178cbc5e1e1f0ac67feb64da2f8e82e099/src/troy_west/arche/spec.clj#L36

% conllu-clj : ifn? for `keyfn`, but can only be one of 2 predefined def's
% https://github.com/ysmiraak/conllu-clj/blob/6bc02c8f3a28dcea871c20fb965878b21fb0c5e5/src/conllu/eval.clj#L19
% - 2 more ifn?'s, arbitrary transformation functions
% https://github.com/ysmiraak/conllu-clj/blob/564e64a94cfde69f58dc37da183e735ebd5a07bb/src/conllu/parse.clj#L42

% planck : TCP data handlers are ifn?
% https://github.com/mfikes/planck/blob/3bc8b174834cf413dbc7415f7af30955adcc27b0/planck-cljs/src/planck/socket/alpha.cljs#L11-L12

% owlet : callback is ifn?
% https://github.com/codefordenver/owlet/blob/4864e0cbc7726501cc58a1362347f07f10524ed7/src/cljs/owlet/views/confirm.cljs#L12

% sqlingvo : evaluation fn is ifn? + another (latter could be enum of fns tbh)
% https://github.com/r0man/sqlingvo/blob/183014264e998366cdb906dbfe35a984c7d5443f/src/sqlingvo/db.cljc

% proletariat : 2 HOF helpers with IFn (reduce, conj wrappers)
% https://github.com/LiaisonTechnologies/proletariat/blob/2a9a8cb8185785cb1d12376da21ddb97d5e43d51/src/proletariat/core.clj#L566

% mazes : ifn? for predicate arg (but rest of fn is also sparsely annotated with sequential?)
% https://github.com/amacdougall/mazes/blob/1766a5fb2a3bbfc3141f44c09a2477a1ec65edef/src/cljc/mazes/generators/wilson.cljc#L36

% Arcadia : listener is ifn?
% https://github.com/arcadia-unity/Arcadia/blob/a0f1ee9f3d8a5b248bb415001d2d0cb2d27527db/Source/arcadia/internal/state.clj#L52

% hive : callback is ifn?
% https://github.com/hiposfer/hive/blob/f4323cc6ddba894942ba37329d4a5f7f7f974024/src/hive/services/raw/location.cljs#L12

% datacore : map of callbacks is ifn? vals, + 4 function inputs as ifn?
% https://github.com/stathissideris/datacore/blob/e4ab7f4822edfccca821fb8f4f9ec81a69e9d056/src/datacore/cells.clj#L59

% ambiparse : predicate is ifn?
% https://github.com/brandonbloom/ambiparse/blob/eeb047878e4990a877810ac4805a45d8cfe9acfb/src/ambiparse/gll.clj#L175

\subsection{Conclusions}

% how does no polymorphism interact with fspec semantics? are they more useful together?
